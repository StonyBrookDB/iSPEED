/* 
 *
 *   It can map objects to their respective tiles given 
 *   a partition schema which is read from a disk
 * or it can be used to extract MBBs from objects
 *
 * */

#include <transform/manipulate_3d.hpp>

using namespace std;

/* Performance metrics */
clock_t start_reading_data;
clock_t start_query_exec;

clock_t total_reading;
clock_t total_query_exec;

const string STR_3D_HEADER = "OFF";

//parameters
bool extract_mbb = false;
bool read_mbb = false;
bool drop_join_idx = false;
bool reading_mbb = false;
int sid_second_set = 2;
char *cachefilename = "";

/* Build indexing on tile boundaries from cache file */
bool build_index_tiles(IStorageManager* &storage, ISpatialIndex * &spidx,
	std::map<SpatialIndex::id_type, std::string> *id_tiles) {
	// build spatial index on tile boundaries 
	id_type  indexIdentifier;
	GEOSDataStreamFileTile stream(cachefilename, id_tiles); // input from cache file
	storage = StorageManager::createNewMemoryStorageManager();
	spidx   = RTree::createAndBulkLoadNewRTree(RTree::BLM_STR, stream, *storage, 
			FillFactor,
			IndexCapacity,
			LeafCapacity,
			3, 
			RTree::RV_RSTAR, indexIdentifier);

	// Error checking 
	return spidx->isIndexValid();
}

/* Process standard input and emit objects to their respective partitions */
void process_input(IStorageManager * &storage, ISpatialIndex * &spidx,
		std::map<id_type, string> *id_tiles) {
	
	bool firstLineRead = false;

	MyVisitor vis;

	/* Space info */
	double space_low[3];
	double space_high[3];

	long count_objects = 0;
	#ifdef DEBUG
	long count_emitted = 0;
	long count_bad = 0;
	#endif


	#ifdef DEBUGTIME
	start_reading_data = clock();
	#endif

	// Variables to track
	int random_id = 0;
	if (extract_mbb) {
		struct timeval time; 
		gettimeofday(&time,NULL);
		srand((time.tv_sec * 1000) + (time.tv_usec / 1000));
		random_id = rand() % 10000; // Can use the number of reducers here for better load balancing/key hashing
	}
	
	string input_line;
	vector<string> fields;
	vector<string> inner_fields;
	double tmp_x, tmp_y, tmp_z;
	double low[3];
	double high[3];
	double xx = 20, yy = 20, zz = 20; // buffer size: the maximum MBB of blood vessels

	/* Handling standard input */
	while(cin && getline(cin, input_line) && !cin.eof()){

		// Removal of \r symbol on Windows
		if (input_line.at(input_line.size() - 1) == '\r') {
			input_line = input_line.substr(0, input_line.size() - 1);
		}

		tokenize(input_line, fields, TAB, true);
		count_objects++;
		try {

			// for compressed data
			low[0] = stod(fields[3]);
			low[1] = stod(fields[4]);
			low[2] = stod(fields[5]);
			high[0] = stod(fields[6]);
			high[1] = stod(fields[7]);
			high[2] = stod(fields[8]);
			if(sid_second_set == stod(fields[2])){
				low[0] -= xx;
				low[1] -= yy;
				low[2] -= zz;
				high[0] += xx;
				high[1] += yy;
				high[2] += zz;			
			}

			Region r(low, high, 3);
			/* Find objects matching with intersecting tiles*/	
			spidx->intersectsWithQuery(r, vis);

			#ifdef DEBUG
			cerr << "intersecting with: " << vis.matches.size() << endl;
			#endif
			/* Emit objects to intersecting tiles */
			for (uint32_t i = 0 ; i < vis.matches.size(); i++ ) {
				if (reading_mbb) {
					cout << (*id_tiles)[vis.matches[i]]
						<< TAB << low[0] << TAB << low[1] << TAB << low[2]
						<< TAB << high[0] << TAB << high[1] << TAB << high[2] << endl;

				} else if (drop_join_idx) {
					// Append tile id only
					cout <<  (*id_tiles)[vis.matches[i]]
						<< TAB << input_line <<  endl ;
				} else {
					// Append tile id and join index

					cout <<  (*id_tiles)[vis.matches[i]]
						<< TAB << fields[2]
						//							<< object_id
						<< TAB << fields[1] 
						// MBB Info	
						<< TAB << low[0] << TAB << low[1] << TAB << low[2]
						<< TAB << high[0] << TAB << high[1] << TAB << high[2]
						<< TAB << fields[9] << TAB << fields[10] << endl; // offset is the beginning point of this object

				}
				#ifdef DEBUG
				count_emitted++;
				#endif
			}
			vis.matches.clear();

		}catch (...) {
			#ifdef DEBUG
			count_bad++;
			cerr << "WARNING: Record is not well formatted " << input_line << endl;
			#endif
			continue; // ignore bad formatting and continue
		}

		fields.clear();

		#ifdef DEBUGTIME
		total_query_exec += clock() - start_query_exec;
		start_reading_data = clock();
		#endif
	}
	/* Output dimensions of space */
	if (extract_mbb) {
		cout << "-1" << TAB << space_low[0] << TAB << space_low[1] << TAB << space_low[2] 
			<< TAB << space_high[0]	<< TAB << space_high[1]	<< TAB << space_high[2] << TAB << count_objects << endl;
	}

	#ifdef DEBUG
	/* Output useful statistics */
	cerr << "Number of processed objects: " << count_objects << endl;
	cerr << "Number of times objects were emitted: " << count_emitted << endl;
	cerr << "Number of not well formatted objects: " << count_bad << endl;
	#endif
}


int main(int argc, char **argv) {	
	std::map<id_type, string> id_tiles;

	//if cache file is given, then we need not extract mbb, just load the mbbs
	//from the cache file
	IStorageManager * storage = NULL;
	ISpatialIndex * spidx = NULL;
	if (!extract_mbb) {
		if( !build_index_tiles(storage, spidx, &id_tiles)) {
			#ifdef DEBUG
			cerr << "ERROR: Index building on tile structure has failed ." << std::endl;
			#endif
			return 1 ;
		} else {
			#ifdef DEBUG
			cerr << "GRIDIndex Generated successfully." << endl;
			#endif
		}
	}

	// Process input line by line
	process_input(storage, spidx, &id_tiles);

	/* Clean up indices */
	delete spidx;
	delete storage;

	id_tiles.clear();

	cout.flush();
	cerr.flush();

	return 0;

}


